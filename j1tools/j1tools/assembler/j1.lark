// Ignore whitespace
%import common.WS
%ignore WS

// Define what a comment looks like and ignore it
COMMENT: ";" /[^\n]*/
%ignore COMMENT

// Define what a number looks like - treat entire number as one token
HEX: /#\$[0-9a-fA-F]+/
DECIMAL: /#[0-9]+/

// Define what an identifier looks like (for labels)
IDENT: /[a-zA-Z][a-zA-Z0-9_]*/

// Add COLON token definition
COLON: ":"

// ALU Operations
T: "T"
N: "N"
PLUS: "+"
MINUS: "-"
ALU_AND: "&"
ALU_OR: "|"
ALU_XOR: "^"
ALU_NOT: "~"
EQUALS: "=="
LESS: "<"
ULESS: "u<"
LSHIFT: "<<"
RSHIFT: ">>"
ARSHIFT: ">>>"
INCREMENT: "1+"
DECREMENT: "1-"
DOUBLE: "2*"
HALF: "2/"

// Stack and Memory Modifiers
T_TO_N: "T->N"
T_TO_R: "T->R"
N_TO_MEM: "N->[T]"
N_TO_IO: "N->io[T]"
IO_READ: "IORD"
DINT: "fDINT"
EINT: "fEINT"
RET: "RET"
STACK_D: /d[+-][012]/
STACK_R: /r[+-][012]/

// Bracket syntax for modifiers
LBRACKET: "["
RBRACKET: "]"
COMMA: ","

// Define the structure of our program (rules)
?start: program
program: statement*
statement: (label | instruction)

// Label rules
labelref: IDENT
label: IDENT COLON

// Number rule
number: (HEX | DECIMAL)

// Instruction rules
instruction: number
           | alu_op modifiers?
           | jump_op labelref
           | stack_words
           | arith_words

// ALU instruction rules (reordered to prioritize longer patterns)
alu_op: T PLUS N
      | T MINUS N
      | T ALU_AND N
      | T ALU_OR N
      | T ALU_XOR N
      | ALU_NOT T
      | N EQUALS T
      | N LESS T
      | N ULESS T
      | N LSHIFT T
      | N RSHIFT T
      | N ARSHIFT T
      | INCREMENT
      | DECREMENT
      | DOUBLE
      | HALF
      | T
      | N

// Modifier rules
modifier: T_TO_N
        | T_TO_R
        | N_TO_MEM
        | N_TO_IO
        | IO_READ
        | DINT
        | EINT
        | RET
        | STACK_D
        | STACK_R

modifier_list: modifier ("," modifier)*

modifiers: LBRACKET modifier_list RBRACKET

// Jump Instructions
JMP: "JMP"      // 0000 base
ZJMP: "ZJMP"    // 2000 base
CALL: "CALL"    // 4000 base    

// Jump instruction rules
jump_op: JMP
       | ZJMP
       | CALL

// Stack Operation Words
DUP: "DUP"
DROP: "DROP"
SWAP: "SWAP"
OVER: "OVER"
NIP: "NIP"
NOOP: "NOOP"
// Return Stack Operations
TO_R: ">R"
R_FROM: "R>"
R_FETCH: "R@"

// Stack operation rules
stack_words: DUP
          | DROP
          | SWAP
          | OVER
          | NIP
          | NOOP
          // Return Stack Operations
          | TO_R
          | R_FROM
          | R_FETCH

// High-Level Arithmetic/Logic words
ADD: "ADD"
SUBTRACT: "SUBTRACT"
AND: "AND"
OR: "OR"
XOR: "XOR"
INVERT: "INVERT"

arith_words: ADD
           | SUBTRACT
           | AND
           | OR
           | XOR
           | INVERT
